// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: 0009_user_follows.sql

package database

import (
	"context"
	"database/sql"
)

const getFollowersByUserId = `-- name: GetFollowersByUserId :many
select 
    ub.user_id,
    ub.user_logout_time,
    case 
        when ub.user_state = 2 and ub.user_logout_time is not null and TIMESTAMPDIFF(MINUTE, ub.user_logout_time, NOW()) >= 10 then 3
        when ub.user_state = 2 and (ub.user_logout_time is null or TIMESTAMPDIFF(MINUTE, ub.user_logout_time, NOW()) < 10) then 2
        when ub.user_state = 1 then 1
        else 3
    end as calculated_user_state
from user_base ub
inner join user_follows uf 
    on ub.user_id = uf.follower_id
where uf.follower_id = ?
`

type GetFollowersByUserIdRow struct {
	UserID              int32
	UserLogoutTime      sql.NullTime
	CalculatedUserState int32
}

func (q *Queries) GetFollowersByUserId(ctx context.Context, followerID sql.NullInt64) ([]GetFollowersByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowersByUserId, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowersByUserIdRow
	for rows.Next() {
		var i GetFollowersByUserIdRow
		if err := rows.Scan(&i.UserID, &i.UserLogoutTime, &i.CalculatedUserState); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserState = `-- name: UpdateUserState :exec
update user_base
set user_state = ?
where user_id = ?
`

type UpdateUserStateParams struct {
	UserState uint8
	UserID    int32
}

func (q *Queries) UpdateUserState(ctx context.Context, arg UpdateUserStateParams) error {
	_, err := q.db.ExecContext(ctx, updateUserState, arg.UserState, arg.UserID)
	return err
}
